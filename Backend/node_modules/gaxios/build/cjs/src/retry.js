"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRetryConfig = getRetryConfig;
async function getRetryConfig(err) {
    let config = getConfig(err);
    if (!err || !err.config || (!config && !err.config.retry)) {
        return { shouldRetry: false };
    }
    config = config || {};
    config.currentRetryAttempt = config.currentRetryAttempt || 0;
    config.retry =
        config.retry === undefined || config.retry === null ? 3 : config.retry;
    config.httpMethodsToRetry = config.httpMethodsToRetry || [
        'GET',
        'HEAD',
        'PUT',
        'OPTIONS',
        'DELETE',
    ];
    config.noResponseRetries =
        config.noResponseRetries === undefined || config.noResponseRetries === null
            ? 2
            : config.noResponseRetries;
    config.retryDelayMultiplier = config.retryDelayMultiplier
        ? config.retryDelayMultiplier
        : 2;
    config.timeOfFirstRequest = config.timeOfFirstRequest
        ? config.timeOfFirstRequest
        : Date.now();
    config.totalTimeout = config.totalTimeout
        ? config.totalTimeout
        : Number.MAX_SAFE_INTEGER;
    config.maxRetryDelay = config.maxRetryDelay
        ? config.maxRetryDelay
        : Number.MAX_SAFE_INTEGER;
    const retryRanges = [
        [100, 199],
        [408, 408],
        [429, 429],
        [500, 599],
    ];
    config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;
    err.config.retryConfig = config;
    const shouldRetryFn = config.shouldRetry || shouldRetryRequest;
    if (!(await shouldRetryFn(err))) {
        return { shouldRetry: false, config: err.config };
    }
    const delay = getNextRetryDelay(config);
    err.config.retryConfig.currentRetryAttempt += 1;
    const backoff = config.retryBackoff
        ? config.retryBackoff(err, delay)
        : new Promise(resolve => {
            setTimeout(resolve, delay);
        });
    if (config.onRetryAttempt) {
        await config.onRetryAttempt(err);
    }
    await backoff;
    return { shouldRetry: true, config: err.config };
}
/**
 * Determine based on config if we should retry the request.
 * @param err The GaxiosError passed to the interceptor.
 */
function shouldRetryRequest(err) {
    const config = getConfig(err);
    if ((err.config.signal?.aborted && err.code !== 'TimeoutError') ||
        err.code === 'AbortError') {
        return false;
    }
    if (!config || config.retry === 0) {
        return false;
    }
    if (!err.response &&
        (config.currentRetryAttempt || 0) >= config.noResponseRetries) {
        return false;
    }
    if (!config.httpMethodsToRetry ||
        !config.httpMethodsToRetry.includes(err.config.method?.toUpperCase() || 'GET')) {
        return false;
    }
    if (err.response && err.response.status) {
        let isInRange = false;
        for (const [min, max] of config.statusCodesToRetry) {
            const status = err.response.status;
            if (status >= min && status <= max) {
                isInRange = true;
                break;
            }
        }
        if (!isInRange) {
            return false;
        }
    }
    config.currentRetryAttempt = config.currentRetryAttempt || 0;
    if (config.currentRetryAttempt >= config.retry) {
        return false;
    }
    return true;
}
/**
 * Acquire the raxConfig object from an GaxiosError if available.
 * @param err The Gaxios error with a config object.
 */
function getConfig(err) {
    if (err && err.config && err.config.retryConfig) {
        return err.config.retryConfig;
    }
    return;
}
/**
 * Gets the delay to wait before the next retry.
 *
 * @param {RetryConfig} config The current set of retry options
 * @returns {number} the amount of ms to wait before the next retry attempt.
 */
function getNextRetryDelay(config) {
    const retryDelay = config.currentRetryAttempt
        ? 0
        : (config.retryDelay ?? 100);
    const calculatedDelay = retryDelay +
        ((Math.pow(config.retryDelayMultiplier, config.currentRetryAttempt) - 1) /
            2) *
            1000;
    const maxAllowableDelay = config.totalTimeout - (Date.now() - config.timeOfFirstRequest);
    return Math.min(calculatedDelay, maxAllowableDelay, config.maxRetryDelay);
}
